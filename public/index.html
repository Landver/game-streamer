<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Week 3 FFmpeg to WebRTC Smoke Test</title>
    <style>
      body { font-family: sans-serif; margin: 16px; }
      .row { display: flex; gap: 16px; margin-top: 12px; }
      #remoteVideo {
        width: min(96vw, 1600px);
        max-width: none;
        max-height: 84vh;
        background: #111;
        border-radius: 8px;
        outline: none;
        cursor: crosshair;
      }
      #remoteVideo.armed {
        box-shadow: 0 0 0 2px #2f80ed;
      }
      input, button { margin-right: 8px; }
      #log { white-space: pre-wrap; font-size: 13px; background: #f5f5f5; padding: 10px; border-radius: 8px; }
    </style>
  </head>
  <body>
    <h2>Week 3: FFmpeg -> Rust -> WebRTC</h2>
    <p>Connect and call <code>ffmpeg-bot</code> to receive desktop stream.</p>

    <label>Session: <input id="sessionId" value="demo-room" /></label>
    <label>Peer: <input id="peerId" value="" /></label>
    <button id="connectBtn">Connect</button>
    <button id="callBtn" disabled>Call stream bot</button>
    <button id="fullscreenBtn">Fullscreen</button>

    <div class="row">
      <div>
        <h4>Remote</h4>
        <video id="remoteVideo" autoplay playsinline tabindex="0"></video>
      </div>
    </div>

    <h4>Log</h4>
    <div id="log"></div>

    <script>
      const logEl = document.getElementById("log");
      const remoteVideo = document.getElementById("remoteVideo");
      const connectBtn = document.getElementById("connectBtn");
      const callBtn = document.getElementById("callBtn");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      const sessionInput = document.getElementById("sessionId");
      const peerInput = document.getElementById("peerId");

      let pc;
      let localPeerId;
      let currentSessionId;
      let pollTimer;
      const knownPeers = new Set();
      const pendingIce = [];
      let inputDc = null;
      let inputArmed = false;
      let lastMoveSentAt = 0;
      const pressedButtons = new Set();
      const pressedKeys = new Set();

      const rtcConfig = {
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      };

      function log(message) {
        const now = new Date().toISOString().slice(11, 19);
        logEl.textContent += `[${now}] ${message}\n`;
      }

      function randomId() {
        return Math.random().toString(36).slice(2, 8);
      }

      async function initPeerConnection() {
        pc = new RTCPeerConnection(rtcConfig);
        const remoteStream = new MediaStream();
        remoteVideo.srcObject = remoteStream;
        inputDc = null;
        setInputArmed(false);

        // Create the input channel from offerer side so SDP includes application m-line.
        inputDc = pc.createDataChannel("input", { ordered: true });
        inputDc.onopen = () => log("Input channel open");
        inputDc.onclose = () => {
          log("Input channel closed");
          setInputArmed(false);
        };
        inputDc.onerror = () => log("Input channel error");

        pc.onicecandidate = (event) => {
          if (!event.candidate) return;
          if (knownPeers.size === 0) return;
          const to = knownPeers.has("ffmpeg-bot")
            ? "ffmpeg-bot"
            : Array.from(knownPeers)[0];
          postSignal("/signal/ice_candidate", {
            type: "ice_candidate",
            from: localPeerId,
            to,
            candidate: JSON.stringify(event.candidate)
          });
        };

        pc.ontrack = (event) => {
          event.streams[0].getTracks().forEach((t) => remoteStream.addTrack(t));
          log("Remote track received");
        };

        pc.ondatachannel = (_event) => {};
        
        pc.onconnectionstatechange = () => {
          log(`PeerConnection state: ${pc.connectionState}`);
        };
        pc.addTransceiver("video", { direction: "recvonly" });
      }

      function setInputArmed(armed) {
        inputArmed = armed;
        remoteVideo.classList.toggle("armed", armed);
        if (!armed) {
          flushPressedInputs();
        }
        if (armed) {
          remoteVideo.focus();
          log("Input active");
        }
      }

      function inputReady() {
        return inputDc && inputDc.readyState === "open" && inputArmed;
      }

      function sendInput(payload) {
        if (!inputReady()) return;
        inputDc.send(JSON.stringify(payload));
      }

      function clamp01(value) {
        return Math.max(0, Math.min(1, value));
      }

      function buttonName(button) {
        if (button === 0) return "left";
        if (button === 1) return "middle";
        if (button === 2) return "right";
        return null;
      }

      function flushPressedInputs() {
        if (!inputDc || inputDc.readyState !== "open") {
          pressedButtons.clear();
          pressedKeys.clear();
          return;
        }
        for (const button of pressedButtons) {
          inputDc.send(JSON.stringify({ v: 1, kind: "mouse_up", button }));
        }
        for (const code of pressedKeys) {
          inputDc.send(JSON.stringify({ v: 1, kind: "key_up", code }));
        }
        pressedButtons.clear();
        pressedKeys.clear();
      }

      function sendMouseMoveFromEvent(event) {
        if (!inputReady()) return;
        const now = performance.now();
        if (now - lastMoveSentAt < 16) return;
        lastMoveSentAt = now;
        const rect = remoteVideo.getBoundingClientRect();
        if (rect.width <= 0 || rect.height <= 0) return;
        const xNorm = clamp01((event.clientX - rect.left) / rect.width);
        const yNorm = clamp01((event.clientY - rect.top) / rect.height);
        sendInput({ v: 1, kind: "mouse_move_abs", x_norm: xNorm, y_norm: yNorm });
      }

      function wheelDeltaToWindows(deltaY) {
        if (deltaY === 0) return 0;
        return deltaY > 0 ? -120 : 120;
      }

      function postSignal(endpoint, payload) {
        return fetch(`${endpoint}?session_id=${encodeURIComponent(currentSessionId)}&peer_id=${encodeURIComponent(localPeerId)}`, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify(payload)
        });
      }

      async function pollSignals() {
        const response = await fetch(`/signal/poll?session_id=${encodeURIComponent(currentSessionId)}&peer_id=${encodeURIComponent(localPeerId)}`);
        const messages = await response.json();
        for (const msg of messages) {
          await handleSignal(msg);
        }
      }

      async function handleSignal(msg) {
        if (msg.type === "join" && msg.peer_id !== localPeerId) {
          knownPeers.add(msg.peer_id);
          log(`Peer joined: ${msg.peer_id}`);
          return;
        }
        if (msg.type === "leave") {
          knownPeers.delete(msg.peer_id);
          log(`Peer left: ${msg.peer_id}`);
          return;
        }
        if (msg.type === "offer" && msg.to === localPeerId) {
          knownPeers.add(msg.from);
          await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await postSignal("/signal/answer", { type: "answer", from: localPeerId, to: msg.from, sdp: answer.sdp });
          log(`Answer sent to ${msg.from}`);
          while (pendingIce.length) {
            const ice = pendingIce.shift();
            await pc.addIceCandidate(ice);
          }
          return;
        }
        if (msg.type === "answer" && msg.to === localPeerId) {
          await pc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
          log(`Answer received from ${msg.from}`);
          return;
        }
        if (msg.type === "ice_candidate" && msg.to === localPeerId) {
          const candidate = new RTCIceCandidate(JSON.parse(msg.candidate));
          if (!pc.remoteDescription) {
            pendingIce.push(candidate);
            return;
          }
          await pc.addIceCandidate(candidate);
        }
      }

      async function startCall() {
        const target = knownPeers.has("ffmpeg-bot")
          ? "ffmpeg-bot"
          : Array.from(knownPeers)[0];
        if (!target) {
          log("No remote peer found");
          return;
        }
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await postSignal("/signal/offer", {
          type: "offer",
          from: localPeerId,
          to: target,
          sdp: offer.sdp
        });
        log(`Offer sent to ${target}`);
      }

      connectBtn.onclick = async () => {
        try {
          connectBtn.disabled = true;
          callBtn.disabled = true;
          log("Connecting...");

          localPeerId = peerInput.value.trim() || randomId();
          peerInput.value = localPeerId;
          currentSessionId = sessionInput.value.trim() || "demo-room";

          await initPeerConnection();

          const joinResponse = await fetch(`/signal/join?session_id=${encodeURIComponent(currentSessionId)}&peer_id=${encodeURIComponent(localPeerId)}`, {
            method: "POST"
          });
          if (!joinResponse.ok) {
            throw new Error(`Join failed with status ${joinResponse.status}`);
          }

          if (pollTimer) clearInterval(pollTimer);
          pollTimer = setInterval(() => {
            pollSignals().catch((err) => log(`Poll error: ${err.message}`));
          }, 300);
          log(`HTTP signaling connected as ${localPeerId}`);
          callBtn.disabled = false;
        } catch (err) {
          log(`Connect failed: ${err.message}`);
          console.error(err);
        } finally {
          connectBtn.disabled = false;
        }
      };

      callBtn.onclick = async () => {
        await startCall();
      };

      fullscreenBtn.onclick = async () => {
        try {
          if (document.fullscreenElement) {
            await document.exitFullscreen();
          } else {
            await remoteVideo.requestFullscreen();
          }
        } catch (err) {
          log(`Fullscreen failed: ${err.message}`);
        }
      };

      window.addEventListener("beforeunload", () => {
        if (!localPeerId || !currentSessionId) return;
        navigator.sendBeacon(
          `/signal/leave?session_id=${encodeURIComponent(currentSessionId)}&peer_id=${encodeURIComponent(localPeerId)}`
        );
      });

      remoteVideo.addEventListener("click", () => {
        setInputArmed(true);
      });

      remoteVideo.addEventListener("contextmenu", (event) => {
        if (inputArmed) event.preventDefault();
      });

      remoteVideo.addEventListener("mousemove", (event) => {
        sendMouseMoveFromEvent(event);
      });

      remoteVideo.addEventListener("mousedown", (event) => {
        const button = buttonName(event.button);
        if (!button || !inputReady()) return;
        event.preventDefault();
        pressedButtons.add(button);
        sendInput({ v: 1, kind: "mouse_down", button });
      });

      remoteVideo.addEventListener("mouseup", (event) => {
        const button = buttonName(event.button);
        if (!button || !inputReady()) return;
        event.preventDefault();
        pressedButtons.delete(button);
        sendInput({ v: 1, kind: "mouse_up", button });
      });

      remoteVideo.addEventListener("wheel", (event) => {
        if (!inputReady()) return;
        event.preventDefault();
        const delta = wheelDeltaToWindows(event.deltaY);
        if (delta === 0) return;
        sendInput({ v: 1, kind: "mouse_wheel", delta_y: delta });
      }, { passive: false });

      window.addEventListener("keydown", (event) => {
        if (!inputReady() || document.activeElement !== remoteVideo) return;
        event.preventDefault();
        if (pressedKeys.has(event.code)) return;
        pressedKeys.add(event.code);
        sendInput({ v: 1, kind: "key_down", code: event.code });
      });

      window.addEventListener("keyup", (event) => {
        if (!inputReady() || document.activeElement !== remoteVideo) return;
        event.preventDefault();
        pressedKeys.delete(event.code);
        sendInput({ v: 1, kind: "key_up", code: event.code });
      });

      window.addEventListener("mousemove", (event) => {
        // Keep drag/move active even when cursor leaves video bounds.
        if (!inputArmed) return;
        sendMouseMoveFromEvent(event);
      });

      window.addEventListener("mouseup", (event) => {
        if (!inputArmed) return;
        const button = buttonName(event.button);
        if (!button || !pressedButtons.has(button)) return;
        pressedButtons.delete(button);
        sendInput({ v: 1, kind: "mouse_up", button });
      });

      window.addEventListener("blur", () => {
        flushPressedInputs();
      });

      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState !== "visible") {
          flushPressedInputs();
        }
      });

    </script>
  </body>
</html>
